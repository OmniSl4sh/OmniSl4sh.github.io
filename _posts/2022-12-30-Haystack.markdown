---
layout: post
title:  "HTB Writeup [Linux - Easy] - Haystack"
published: false
---

![](/Assets/Box/Box.png)

## Summary
- Haystack was quite a nice Linux box, it had an unprotected Elastic Search instance which let us enumerate all indeces (equivalent to database tables).
- Hidden amongst the data, was a username and password encoded in base64. Those worked and got us on the box via SSH.
- On the box, we detect a locally-listening Kibana interface which we expose to ourselves through an SSH tunnel.
- After fingerprinting Kibana, we find the version vulnerable to Local File Inclusion.
- Having access to file system, we place a Node.JS reverse shell and include it using the LFI to get code execution as the `kibana` user.
- Noticing the logstash service running as `root`, we check if we can modify or abuse its filters to run command in a privileged context.
- The filters weren't writable, but they extracted and ran commands from a directory where we had write access.
- After placing a file with a matching name and inserting our command in the expected format, our code gets executed as `root` and we own the box.

---

## NMAP
```
PORT     STATE SERVICE VERSION              
22/tcp   open  ssh     OpenSSH 7.4 (protocol 2.0)
| ssh-hostkey:                                                                                                    
|   2048 2a:8d:e2:92:8b:14:b6:3f:e4:2f:3a:47:43:23:8b:2b (RSA)
|   256 e7:5a:3a:97:8e:8e:72:87:69:a3:0d:d1:00:bc:1f:09 (ECDSA)
|_  256 01:d2:59:b2:66:0a:97:49:20:5f:1c:84:eb:81:ed:95 (ED25519)
80/tcp   open  http    nginx 1.12.2                                                                               
|_http-title: Site doesn't have a title (text/html).
|_http-server-header: nginx/1.12.2          
9200/tcp open  http    nginx 1.12.2                                                                               
| http-methods:                                                                                                   
|_  Potentially risky methods: DELETE                                                                             
|_http-title: Site doesn't have a title (application/json; charset=UTF-8).                      
|_http-server-header: nginx/1.12.2 
```
This nmap shows:
- SSH on its default port (that version allows for username enumeration)
- HTTP on both ports 80 and 9200

## Checking Port 80
Here we only see a picture of a.. well.. a needle in a haystack
![](port-80-image.jpg)

we use `wget` to download it and then check for anything in it's metadata using `exiftool`

![](download-and-exif-needle-jpeg.jpg)

but we don't find anything here.

we also ran `gobuster` without funding anything. so we moved on.

## Enumerating Elasticsearch
On port 9200, we instantly notice a keyword: "Elasticsearch"

![](elastic-search-found.jpg)

Enumerating Elastic is pretty straightforward following this awesome [HackTricks](https://book.hacktricks.xyz/network-services-pentesting/9200-pentesting-elasticsearch) page.

Some basic Elastsearch terminology before we start:

- Index: a collection of documents
- Document: a set of key-value pairs

Per index, we want to retrieve as many documents as we can so we can access the most amount of data.

to get the list of indeces, we can use `curl` to send a GET request to the `/_cat/indices?v` endpoint.

![](cat-elastic-indeces.jpg)

we get back 3 indeces:
1. .kibana
2. quotes
3. bank

to get the documents for each index, we will again use `curl` but with a different URL format: `/<INDEX_NAME>/_search?size=<NUMBER_OF_DOCUMENTS>`

and will pipe the JSON output to `jq` to make it more pretty and accessible.

starting with the `.kibana` index:

![](kibana-index.jpg)

we don't find much here.

so we go for the `quotes` index next:

![](quotes-index.jpg)

looks like a bunch of junk. but it also looks like a haystack :D

where the needle though?

to make the search easier, we decide to search for any special characters using `grep`

this way we would find anything that's not normal text.

when grepping for the `:`, we find two needles XD

![](finding-two-needles.jpg)

since it's in spanish, we use Google Translate

![](spanish-translate.jpg)

notice from the trailing `=`, we're know they're both base-64 encoded.

decoding them gives us `security` and `spanish.is.key` which correspond to the username and password for SSH

![](ssh-as-security.jpg)

## Lateral Movement via Exploiting Kibana
Right after logging in, we ran a quick [linpeas](https://github.com/carlospolop/PEASS-ng)

after checking a couple of things, we notice a set of new local ports listening:

![](locally-listening-ports.jpg)

so we leverage our SSH access to create 4 easy tunnels:

![](ssh-tunnels.jpg)

going to port 5601, we find kibana:

![](discovering-kibana.jpg)

in the management tab, we find the version:

![](kibana-version.jpg)

a quick search on Google reveals an exploit available:

![](kibana-exploit-search-google.jpg)

checking it, we notice that this exploit is suited to our situation

![](kibana-lfi-github.jpg)

we need to place a javascript reverse shell somewhere readable to all users on the box (like `/tmp`) then include it.

this one here was in the same Github repo as the exploit.

![](JS-rev-shell-code.jpg)

we create `rev.js` using `vi` and modify the host and port

![](rev-js-created.jpg)

then trigger the LFI at `/api/console/api_server?sense_version=@@SENSE_VERSION&apis=../../../../../../.../../../../tmp/rev.js`

![](got-rev-as-kibana.jpg)

we're in as the `kibana` user.

## Exploiting Logstash for Privilege Escalation
Another [linpeas](https://github.com/carlospolop/PEASS-ng) run gets us something interesting:

![](logstash-files-found.jpg)

these files weren't accessible to us as the `security` user. but now are.

furthermore, we know that the logstash process is running as `root`

### ---> insert pic

Logstash can be used to perform actions on logs (ex: parse them in a specific format) to make search easier.

![](checking-logstash-conf-files.jpg)